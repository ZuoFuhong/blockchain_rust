## 区块链

简易的区块链项目：https://github.com/Jeiwan/blockchain_go

区块链教程：https://github.com/liuchengxu/blockchain-tutorial


### [一、区块链原型](https://github.com/liuchengxu/blockchain-tutorial/blob/master/content/part-1/basic-prototype.md)

#### 区块

首先从 “区块” 谈起。在区块链中，真正存储有效信息的是区块（block）。而在比特币中，真正有价值的信息就是交易（transaction）。实际上，
交易信息是所有加密货币的价值所在。除此以外，区块还包含了一些技术实现的相关信息，比如版本，当前时间戳和前一个区块的哈希。

#### 区块链

本质上，区块链就是一个有着特定结构的数据库，是一个有序，每一个块都连接到前一个块的链表。也就是说，区块按照插入的顺序进行存储，每个块都
与前一个块相连。这样的结构，能够让我们快速地获取链上的最新块，并且高效地通过哈希来检索一个块。


### [二、工作量证明](https://github.com/liuchengxu/blockchain-tutorial/blob/master/content/part-2/proof-of-work.md)

#### 工作量证明

区块链的一个关键点就是，一个人必须经过一系列困难的工作，才能将数据放入到区块链中。正是由于这种困难的工作，才保证了区块链的安全和一致。
此外，完成这个工作的人，也会获得相应奖励（这也就是通过挖矿获得币）。

这个机制与生活现象非常类似：一个人必须通过努力工作，才能够获得回报或者奖励，用以支撑他们的生活。在区块链中，是通过网络中的参与者（矿工）
不断的工作来支撑起了整个网络。矿工不断地向区块链中加入新块，然后获得相应的奖励。在这种机制的作用下，新生成的区块能够被安全地加入到区块
链中，它维护了整个区块链数据库的稳定性。值得注意的是，完成了这个工作的人必须要证明这一点，即他必须要证明他的确完成了这些工作。

整个 “努力工作并进行证明” 的机制，就叫做工作量证明（proof-of-work）。要想完成工作非常地不容易，因为这需要大量的计算能力：即便是高性
能计算机，也无法在短时间内快速完成。另外，这个工作的困难度会随着时间不断增长，以保持每 10 分钟出 1 个新块的速度。`在比特币中，这个工作
就是找到一个块的哈希`，同时这个哈希满足了一些必要条件。这个哈希，也就充当了证明的角色。因此，寻求证明（寻找有效哈希），就是矿工实际要做
的事情。

#### 哈希计算

获得指定数据的一个哈希值的过程，就叫做哈希计算。一个哈希，就是对所计算数据的一个唯一表示。对于一个哈希函数，输入任意大小的数据，它会输
出一个固定大小的哈希值。下面是哈希的几个关键特性：

- 1.无法从一个哈希值恢复原始数据。也就是说，哈希并不是加密。
- 2.对于特定的数据，只能有一个哈希，并且这个哈希是唯一的。
- 3.即使是仅仅改变输入数据中的一个字节，也会导致输出一个完全不同的哈希。

#### Hashcash

比特币使用 Hashcash ，一个最初用来防止垃圾邮件的工作量证明算法。它可以被分解为以下步骤：

- 1.取一些公开的数据（比如，如果是 email 的话，它可以是接收者的邮件地址；在比特币中，它是区块头）
- 2.给这个公开数据添加一个计数器。计数器默认从 0 开始
- 3.将 data(数据) 和 counter(计数器) 组合到一起，获得一个哈希
- 4.检查哈希是否符合一定的条件：

1）如果符合条件，结束

2）如果不符合，增加计数器，重复步骤 3-4

因此，这是一个暴力算法：改变计数器，计算新的哈希，检查，增加计数器，计算哈希，检查，如此往复。这也是为什么说它的计算成本很高，因为这一步
需要如此反复不断地计算和检查。


### [三、持久化和命令行接口](https://github.com/liuchengxu/blockchain-tutorial/blob/master/content/part-3/persistence-and-cli.md)

目前，我们的区块链实现里面并没有用到数据库，而是在每次运行程序时，简单地将区块链存储在内存中。那么一旦程序退出，所有的内容就都消失了。
我们没有办法再次使用这条链，也没有办法与其他人共享，所以我们需要把它存储到磁盘上。


### [四、交易](https://github.com/liuchengxu/blockchain-tutorial/blob/master/content/part-4/transactions-1.md)

交易（transaction）是比特币的核心所在，而区块链唯一的目的，也正是为了能够安全可靠地存储交易。在区块链中，交易一旦被创建，就没有任何人
能够再去修改或是删除它。

由于比特币采用的是 UTXO 模型，并非账户模型，并不直接存在“余额”这个概念，余额需要通过遍历整个交易历史得来。

#### 交易

一笔交易由一些输入（input）和输出（output）组合而来：

```
type Transaction struct {
	ID   []byte
	Vin  []TXInput
	Vout []TXOutput
}
```

对于每一笔新的交易，它的输入会引用（reference）之前一笔交易的输出（这里有个例外，coinbase 交易），引用就是花费的意思。所谓引用之前的
一个输出，也就是将之前的一个输出包含在另一笔交易的输入当中，就是花费之前的交易输出。交易的输出，就是币实际存储的地方。


#### 交易输出

输出主要包含两部分：

```
type TXOutput struct {
	Value        int
	ScriptPubKey string
}
```

- 1.一定量的比特币(Value)
- 2.一个锁定脚本(ScriptPubKey)，要花这笔钱，必须要解锁该脚本。

实际上，正是输出里面存储了“币”（注意，也就是上面的 Value 字段）。而这里的存储，指的是用一个数学难题对输出进行锁定，这个难题被存储在 
`ScriptPubKey`里面。在内部，比特币使用了一个叫做`Script`的脚本语言，用它来定义锁定和解锁输出的逻辑。

> 在比特币中，value 字段存储的是 satoshi 的数量，而不是 BTC 的数量。一个 satoshi 等于一亿分之一的 BTC(0.00000001 BTC)，这也
是比特币里面最小的货币单位（就像是 1 分的硬币）。

关于输出，非常重要的一点是：它们是`不可再分的（indivisible）`。也就是说，你无法仅引用它的其中某一部分。要么不用，如果要用，必须一次
性用完。当一个新的交易中引用了某个输出，那么这个输出必须被全部花费。如果它的值比需要的值大，那么就会产生一个找零，找零会返还给发送方。
这跟现实世界的场景十分类似，当你想要支付的时候，如果一个东西值 1 美元，而你给了一个 5 美元的纸币，那么你会得到一个 4 美元的找零。

创建新的交易，并通过挖出新块的方式将交易打包到区块链中。不过，比特币并不是一连串立刻完成这些事情（虽然我们目前的实现是这么做的）。相反，
它会将所有新的交易放到一个内存池中（mempool），然后当矿工准备挖出一个新块时，它就从内存池中取出所有交易，创建一个候选块。只有当包含这
些交易的块被挖出来，并添加到区块链以后，里面的交易才开始确认。

#### 交易输入

```
type TXInput struct {
	Txid      []byte
	Vout      int
	ScriptSig string
}
```

正如之前所提到的，一个输入引用了之前交易的一个输出：Txid 存储的是之前交易的 ID，Vout 存储的是该输出在那笔交易中所有输出的索引（因为一
笔交易可能有多个输出，需要有信息指明是具体的哪一个）。ScriptSig 是一个脚本，提供了可解锁输出结构里面`ScriptPubKey`字段的数据。如果 
`ScriptSig`提供的数据是正确的，那么输出就会被解锁，然后被解锁的值就可以被用于产生新的输出；如果数据不正确，输出就无法被引用在输入中，
或者说，无法使用这个输出。这种机制，保证了用户无法花费属于其他人的币。


#### coinbase

在比特币中，最先有输出，然后才有输入。换而言之，第一笔交易只有输出，没有输入。

当矿工挖出一个新的块时，它会向新的块中添加一个`coinbase`交易。`coinbase`交易是一种特殊的交易，它不需要引用之前一笔交易的输出。它
“凭空”产生了币（也就是产生了新币），这是矿工获得挖出新块的奖励，也可以理解为“发行新币”。

在区块链的最初，也就是第一个块，叫做创世块。正是这个创世块，产生了区块链最开始的输出。对于创世块，不需要引用之前的交易输出。因为在创
世块之前根本不存在交易，也就没有不存在交易输出。

`coinbase`交易只有一个输出，没有输入。在我们的实现中，它表现为`Txid`为空，`Vout`等于 -1。并且，在当前实现中，`coinbase`交易也
没有在`ScriptSig`中存储脚本，而只是存储了一个任意的字符串`data`。

> 在比特币中，第一笔 coinbase 交易包含了如下信息：“The Times 03/Jan/2009 Chancellor on brink of second bailout for banks”。`

`subsidy`是挖出新块的奖励金。在比特币中，实际并没有存储这个数字，而是基于区块总数进行计算而得：区块总数除以 210000 就是`subsidy`。
挖出创世块的奖励是 50 BTC，每挖出 210000 个块后，奖励减半。在我们的实现中，这个奖励值将会是一个常量（至少目前是）。


#### 将交易保存到区块链

每个块必须存储至少一笔交易。如果没有交易，也就不可能出新的块。

#### 未花费交易输出

我们需要找到所有的未花费交易输出（unspent transactions outputs, UTXO）。未花费（unspent） 指的是这个输出还没有被包含在任何
交易的输入中，或者说没有被任何输入引用。

由于交易被存储在区块里，所以我们不得不检查区块链里的每一笔交易。

如果一个输出被一个地址锁定，并且这个地址恰好是我们要找的地址，那么这个输出就是我们想要的。不过在获取它之前，我们需要检查该输出是否已
经被包含在一个交易的输入中，也就是检查它是否已经被花费了。

账户余额就是由账户地址锁定的所有未花费交易输出的总和。


### [五、地址](https://github.com/liuchengxu/blockchain-tutorial/blob/master/content/part-5/address.md)

#### 比特币地址

比特币地址是完全公开的，如果你想要给某个人发送币，只需要知道他的地址就可以了。但是，地址（尽管地址也是独一无二的）并不是用来证明你是
一个“钱包”所有者的信物。实际上，所谓的地址，只不过是将公钥表示成人类可读的形式而已，因为原生的公钥人类很难阅读。在比特币中，你的身份
（identity）就是一对（或者多对）保存在你的电脑（或者你能够获取到的地方）上的公钥（public key）和私钥（private key）。比特币基
于一些加密算法的组合来创建这些密钥，并且保证了在这个世界上没有其他人能够取走你的币，除非拿到你的密钥。

#### 公钥加密

公钥加密（public-key cryptography）算法使用的是成对的密钥：公钥和私钥。公钥并不是敏感信息，可以告诉其他人。但是，私钥绝对不能
告诉其他人：只有所有者（owner）才能知道私钥，能够识别，鉴定和证明所有者身份的就是私钥。

#### 数字签名

在数学和密码学中，有一个数字签名（digital signature）的概念，算法可以保证：

- 1.当数据从发送方传送到接收方时，数据不会被修改；
- 2.数据由某一确定的发送方创建；
- 3.发送方无法否认发送过数据这一事实。

通过在数据上应用签名算法（也就是对数据进行签名），你就可以得到一个签名，这个签名晚些时候会被验证。生成数字签名需要一个私钥，而验证
签名需要一个公钥。

#### Base58

比特币使用 Base58 算法将公钥转换成人类可读的形式。这个算法跟著名的 Base64 很类似，区别在于它使用了更短的字母表：为了避免一些利用
字母相似性的攻击，从字母表中移除了一些字母。也就是，没有这些符号：0(零)，O(大写的 o)，I(大写的i)，l(小写的 L)，因为这几个字母看
着很像。另外，也没有 + 和 / 符号。


#### 实现地址

一个钱包只有一个密钥对而已。我们需要 Wallets 类型来保存多个钱包的组合，将它们保存到文件中，或者从文件中进行加载。Wallet 的构造函
数会生成一个新的密钥对。newKeyPair 函数非常直观：ECDSA 基于椭圆曲线，所以我们需要一个椭圆曲线。接下来，使用椭圆生成一个私钥，然
后再从私钥生成一个公钥。有一点需要注意：在基于椭圆曲线的算法中，公钥是曲线上的点。因此，公钥是 X，Y 坐标的组合。在比特币中，这些坐
标会被连接起来，然后形成一个公钥。

将一个公钥转换成一个 Base58 地址需要以下步骤：

- 1.使用 RIPEMD160(SHA256(PubKey)) 哈希算法，取公钥并对其哈希两次
- 2.给哈希加上地址生成算法版本的前缀
- 3.对于第二步生成的结果，使用 SHA256(SHA256(payload)) 再哈希，计算校验和。校验和是结果哈希的前四个字节。
- 4.将校验和附加到 version+PubKeyHash 的组合中。
- 5.使用 Base58 对 version+PubKeyHash+checksum 组合进行编码。

至此，就可以得到一个`真实的比特币地址`，你甚至可以在[blockchain.info](https://blockchain.info)查看它的余额。

#### 实现签名

交易必须被签名，因为这是比特币里面保证发送方不会花费属于其他人的币的唯一方式。如果一个签名是无效的，那么这笔交易就会被认为是无效的，
因此，这笔交易也就无法被加到区块链中。
